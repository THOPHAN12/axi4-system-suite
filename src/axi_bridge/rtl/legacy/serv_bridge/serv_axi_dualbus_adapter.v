/* 
 * serv_axi_dualbus_adapter.v
 *
 * Helper block that collapses the two AXI master ports generated by
 * serv_axi_wrapper (instruction read port + data read/write port) into a
 * single AXI4-Lite style master interface.  This allows one SERV core to
 * appear as a single AXI master when connecting to small crossbars or
 * arbiters.
 *
 * - Write channels are driven exclusively by the data bus and are passed
 *   through without modification.
 * - Read channels can originate from either the instruction bus (read-only)
 *   or the data bus. A simple round-robin arbiter provides fairness between
 *   the two sources. The response path uses a single-bit tracker because
 *   the Wishbone-to-AXI converters only issue one outstanding transaction
 *   at a time.
 */

`timescale 1ns/1ps

module serv_axi_dualbus_adapter #(
    parameter integer ADDR_WIDTH = 32,
    parameter integer DATA_WIDTH = 32,
    parameter integer ID_WIDTH   = 4
) (
    input  wire                        ACLK,
    input  wire                        ARESETN,

    // ------------------------------------------------------------------
    // SERV Instruction Port (read-only)
    // ------------------------------------------------------------------
    input  wire [ID_WIDTH-1:0]         inst_arid,
    input  wire [ADDR_WIDTH-1:0]       inst_araddr,
    input  wire [7:0]                  inst_arlen,
    input  wire [2:0]                  inst_arsize,
    input  wire [1:0]                  inst_arburst,
    input  wire [1:0]                  inst_arlock,
    input  wire [3:0]                  inst_arcache,
    input  wire [2:0]                  inst_arprot,
    input  wire [3:0]                  inst_arqos,
    input  wire [3:0]                  inst_arregion,
    input  wire                        inst_arvalid,
    output wire                        inst_arready,

    output wire [ID_WIDTH-1:0]         inst_rid,
    output wire [DATA_WIDTH-1:0]       inst_rdata,
    output wire [1:0]                  inst_rresp,
    output wire                        inst_rlast,
    output wire                        inst_rvalid,
    input  wire                        inst_rready,

    // ------------------------------------------------------------------
    // SERV Data Port (read/write)
    // ------------------------------------------------------------------
    input  wire [ID_WIDTH-1:0]         data_awid,
    input  wire [ADDR_WIDTH-1:0]       data_awaddr,
    input  wire [7:0]                  data_awlen,
    input  wire [2:0]                  data_awsize,
    input  wire [1:0]                  data_awburst,
    input  wire [1:0]                  data_awlock,
    input  wire [3:0]                  data_awcache,
    input  wire [2:0]                  data_awprot,
    input  wire [3:0]                  data_awqos,
    input  wire [3:0]                  data_awregion,
    input  wire                        data_awvalid,
    output wire                        data_awready,

    input  wire [DATA_WIDTH-1:0]       data_wdata,
    input  wire [(DATA_WIDTH/8)-1:0]   data_wstrb,
    input  wire                        data_wlast,
    input  wire                        data_wvalid,
    output wire                        data_wready,

    output wire [ID_WIDTH-1:0]         data_bid,
    output wire [1:0]                  data_bresp,
    output wire                        data_bvalid,
    input  wire                        data_bready,

    input  wire [ID_WIDTH-1:0]         data_arid,
    input  wire [ADDR_WIDTH-1:0]       data_araddr,
    input  wire [7:0]                  data_arlen,
    input  wire [2:0]                  data_arsize,
    input  wire [1:0]                  data_arburst,
    input  wire [1:0]                  data_arlock,
    input  wire [3:0]                  data_arcache,
    input  wire [2:0]                  data_arprot,
    input  wire [3:0]                  data_arqos,
    input  wire [3:0]                  data_arregion,
    input  wire                        data_arvalid,
    output wire                        data_arready,

    output wire [ID_WIDTH-1:0]         data_rid,
    output wire [DATA_WIDTH-1:0]       data_rdata,
    output wire [1:0]                  data_rresp,
    output wire                        data_rlast,
    output wire                        data_rvalid,
    input  wire                        data_rready,

    // ------------------------------------------------------------------
    // Collapsed AXI4-Lite Master Interface
    // ------------------------------------------------------------------
    output wire [ADDR_WIDTH-1:0]       AXI_awaddr,
    output wire [2:0]                  AXI_awprot,
    output wire                        AXI_awvalid,
    input  wire                        AXI_awready,

    output wire [DATA_WIDTH-1:0]       AXI_wdata,
    output wire [(DATA_WIDTH/8)-1:0]   AXI_wstrb,
    output wire                        AXI_wvalid,
    input  wire                        AXI_wready,

    input  wire [1:0]                  AXI_bresp,
    input  wire                        AXI_bvalid,
    output wire                        AXI_bready,

    output wire [ADDR_WIDTH-1:0]       AXI_araddr,
    output wire [2:0]                  AXI_arprot,
    output wire                        AXI_arvalid,
    input  wire                        AXI_arready,

    input  wire [DATA_WIDTH-1:0]       AXI_rdata,
    input  wire [1:0]                  AXI_rresp,
    input  wire                        AXI_rvalid,
    input  wire                        AXI_rlast,
    output wire                        AXI_rready
);

    // ===============================================================
    // Write path : direct pass-through from SERV data bus
    // ===============================================================
    assign AXI_awaddr  = data_awaddr;
    assign AXI_awprot  = data_awprot;
    assign AXI_awvalid = data_awvalid;
    assign data_awready = AXI_awready;

    assign AXI_wdata   = data_wdata;
    assign AXI_wstrb   = data_wstrb;
    assign AXI_wvalid  = data_wvalid;
    assign data_wready = AXI_wready;

    assign data_bid    = data_awid;
    assign data_bresp  = AXI_bresp;
    assign data_bvalid = AXI_bvalid;
    assign AXI_bready  = data_bready;

    // ===============================================================
    // Read path : round-robin arbiter between instruction & data bus
    // ===============================================================
    localparam SRC_INST = 1'b0;
    localparam SRC_DATA = 1'b1;

    reg                        rr_select;
    reg                        read_active;
    reg                        active_src;

    wire                       arb_idle    = ~read_active;
    wire                       inst_req    = inst_arvalid;
    wire                       data_req    = data_arvalid;

    wire                       choose_inst;
    wire                       choose_data;

    assign choose_inst = arb_idle &&
                         inst_req &&
                         (!data_req || (data_req && rr_select == SRC_INST));

    assign choose_data = arb_idle &&
                         data_req &&
                         (!inst_req || (inst_req && rr_select == SRC_DATA));

    // Grant toggling for fairness
    always @(posedge ACLK or negedge ARESETN) begin
        if (!ARESETN) begin
            rr_select   <= SRC_INST;
            read_active <= 1'b0;
            active_src  <= SRC_INST;
        end else begin
            if (choose_inst && AXI_arready) begin
                active_src  <= SRC_INST;
                read_active <= 1'b1;
                rr_select   <= SRC_DATA;
            end else if (choose_data && AXI_arready) begin
                active_src  <= SRC_DATA;
                read_active <= 1'b1;
                rr_select   <= SRC_INST;
            end else if (read_active && AXI_rvalid && AXI_rready && AXI_rlast) begin
                read_active <= 1'b0;
            end
        end
    end

    assign AXI_araddr  = choose_inst ? inst_araddr :
                         choose_data ? data_araddr :
                         {ADDR_WIDTH{1'b0}};

    assign AXI_arprot  = choose_inst ? inst_arprot :
                         choose_data ? data_arprot :
                         3'b000;

    assign AXI_arvalid = choose_inst || choose_data;
    assign inst_arready = choose_inst && AXI_arready;
    assign data_arready = choose_data && AXI_arready;

    // Response routing
    assign AXI_rready  = (active_src == SRC_INST) ? inst_rready :
                         (active_src == SRC_DATA) ? data_rready : 1'b0;

    assign inst_rvalid = (active_src == SRC_INST) ? AXI_rvalid : 1'b0;
    assign inst_rlast  = (active_src == SRC_INST) ? AXI_rlast : 1'b0;
    assign inst_rdata  = (active_src == SRC_INST) ? AXI_rdata : {DATA_WIDTH{1'b0}};
    assign inst_rresp  = (active_src == SRC_INST) ? AXI_rresp : 2'b00;
    assign inst_rid    = inst_arid;

    assign data_rvalid = (active_src == SRC_DATA) ? AXI_rvalid : 1'b0;
    assign data_rlast  = (active_src == SRC_DATA) ? AXI_rlast : 1'b0;
    assign data_rdata  = (active_src == SRC_DATA) ? AXI_rdata : {DATA_WIDTH{1'b0}};
    assign data_rresp  = (active_src == SRC_DATA) ? AXI_rresp : 2'b00;
    assign data_rid    = data_arid;

endmodule

